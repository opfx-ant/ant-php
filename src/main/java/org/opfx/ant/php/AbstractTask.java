package org.opfx.ant.php;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.Vector;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.ExecTask;
import org.apache.tools.ant.taskdefs.Execute;
import org.apache.tools.ant.taskdefs.Parallel;
import org.apache.tools.ant.taskdefs.Redirector;
import org.apache.tools.ant.taskdefs.condition.Os;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Environment;
import org.apache.tools.ant.types.Environment.Variable;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.FilterChain;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.util.FileUtils;
import org.opfx.ant.php.type.IniSet;

public abstract class AbstractTask extends Task {
	private static String PROPERTY_PHP_DIR = "php.home";
	private static String PHP_EXTENSION_DIRS = "extensions;ext";
	private static String FMT_RESOURCE_PATH_TOOL = "resources/tool/%s.phar";
	private static String FMT_RESOURCE_PATH_TEMPLATE = "resources/template/%s";
	private static String FMT_RESOURCE_PATH_SCRIPT = "resources/script/%s.php";
	private static int MAX_ALLOWED_THREADS = 25;

	/**
	 * The name of the php executable.
	 */
	private String exec;
	/**
	 * The resolved path of the php executable.
	 */
	private File resolvedExec;

	/**
	 * The task's environment used to configure the executor(s).
	 */
	protected Environment env;
	/**
	 * The name of the tool that php will be invoked with (phpunit for example) It
	 * may be null
	 */
	private String tool;
	/**
	 * Tool's version and copyright information
	 */
	private String logo;

	/**
	 * Directory containing the php file to be processed. Optional; if not
	 * explicitly set by calling setSrcDir will be null.
	 */
	protected File srcDir;

	protected File destDir;

	/**
	 * Placeholder for working directory.
	 */
	private File workDir;

	protected File destFile;

	/**
	 * Placeholder for the resolved php extensions dir
	 */
	private File extDir;

	protected Vector<ResourceCollection> sources;

	/**
	 * The patterns that need to included when building the list of files that need
	 * processing.
	 */
	protected String includes;

	/**
	 * The patterns that need to excluded when building the list of files that need
	 * processing.
	 */
	protected String excludes;

	/**
	 * The property used to store this task's processing output; may be null.
	 */
	protected String outputProperty;

	/**
	 * The property used to store this task's processing result; may be null.
	 */
	protected String resultProperty;

	/**
	 * The property used to store this task's error output; may be null.
	 */
	protected String errorProperty;

	/**
	 * Indicates whether this task should fail the build if any errors occur during
	 * its execution.
	 */
	protected boolean failOnError;

	private Parallel scheduler;
	protected boolean parallel;
	private int threadCount;

	/**
	 * List of extensions required by the task.
	 */
	Map<String, String> extensions;

	/**
	 * The ini setting for this task.
	 */
	Vector<IniSet> defines;

	/**
	 * Tracks failure messages generated by executors
	 */
	Vector<String> failures;

	protected Vector<FilterChain> outputFilterChains;

	protected AbstractTask() {
		super();
		exec = "php";
		if (Os.isFamily(Os.FAMILY_WINDOWS)) {
			exec = exec.concat(".exe");
		}
		logo = "";
		extensions = new HashMap<String, String>();
		defines = new Vector<IniSet>();
		scheduler = new Parallel();
		env = new Environment();
		threadCount = MAX_ALLOWED_THREADS;
		parallel = false;
		failures = new Vector<String>();
		failOnError = true;
		outputFilterChains = new Vector<FilterChain>();
	}

	protected AbstractTask(final String tool) {
		this();
		this.tool = tool;
	}

	/**
	 * Adds the given fileset to the list of sources that will be processed.
	 * 
	 * @param fs
	 */
	protected void addFileSet(final FileSet fs) {
		if (sources == null) {
			sources = new Vector<ResourceCollection>();
		}
		sources.add(fs);
	}

	protected IniSet createIni() {
		IniSet set = new IniSet();
		defines.add(set);
		return set;
	}

	protected void setSrcDir(final File dir) {
		srcDir = dir;
	}

	protected void setDestDir(final File dir) {
		destDir = dir;
	}

	protected void setDestFile(final File file) {
		destFile = file;
	}

	/**
	 * Appends <code>excludes</code> to the current list of exclude patterns.
	 *
	 * <p>
	 * Patterns may be separated by a comma or a space.
	 * </p>
	 */
	protected void setExcludes(final String pattern) {
		excludes = pattern;
	}

	/**
	 * Appends <code>excludes</code> to the current list of include patterns.
	 *
	 * <p>
	 * Patterns may be separated by a comma or a space.
	 * </p>
	 */
	protected void setIncludes(final String pattern) {
		includes = pattern;
	}

	protected void setWorkDir(final File dir) {
		workDir = dir;
	}

	/**
	 * Sets the property name that will contain the errors occured during the
	 * execution of this task. The specified property will be set if the task fails.
	 * 
	 * @param property
	 *            the name of the property to set
	 */
	public void setErrorProperty(final String property) {
		errorProperty = property;
	}

	/**
	 * Sets the property name that will contain the result of the execution of this
	 * task. The specified property will contain the exit code of the underlying
	 * process(es) executed by this task.
	 * 
	 * @param property
	 */
	public void setResultProperty(final String property) {
		resultProperty = property;
	}

	/**
	 * Sets the property name that will contain the output generated by the
	 * underlying process(es) executed by this task. The specified property will
	 * contain the generated output regardless of whether the task succedded or
	 * failed. When multiple process are executed in parallel, their output will be
	 * concatenated.
	 * 
	 * @param property
	 *            the name of the property to set
	 */
	public void setOutputProperty(final String property) {
		outputProperty = property;
	}

	/**
	 * Indicates whether the build will continue even if errors occur during the
	 * execution of this task. This value defaults to true.
	 * 
	 * @param flag
	 *            if true stop the build on failure
	 */
	public void setFailOnError(final boolean flag) {
		failOnError = flag;
	}

	/**
	 * 
	 * @param flag
	 */
	protected void setParallel(final boolean flag) {
		parallel = flag;
	}

	/**
	 * Sets the maximum number of allowable threads when executing in parallel.
	 * 
	 * @param count
	 */
	protected void setThreadCount(final int count) {
		threadCount = count;
	}

	@Override
	public void init() throws BuildException {
		super.init();
		workDir = getProject().getBaseDir();
		scheduler.bindToOwner(this);
		scheduler.init();
		useExtension("phar");
		useExtension("tokenizer");
		define("date.timezone", "America/New_York");
	}

	@Override
	public final void execute() throws BuildException {
		validateParameters();
		// PRE-PROCESSING
		// create the directory required for the artifacts generated by
		// this task (if any)
		File targetDir = null;
		if (destDir != null) {
			targetDir = destDir.getParentFile();
		}
		if (destFile != null) {
			targetDir = destFile.getParentFile();
		}
		if (targetDir != null && !targetDir.exists()) {
			// TODO catch security exception
			if (!targetDir.mkdirs()) {
				throw new BuildException(String.format("Failed to create '%s' directory.", String.valueOf(targetDir)));
			}
		}

		if (srcDir != null) {
			FileSet fs = new FileSet();
			fs.setProject(getProject());
			fs.setDir(srcDir);
			fs.setIncludes(includes);
			fs.setExcludes(excludes);
			if (sources == null) {
				sources = new Vector<ResourceCollection>();
			}
			sources.add(fs);
		}
		displayLogo();
		try {
			process();
		} finally {
			if (!failures.isEmpty()) {
				for (String failure : failures) {
					log(failure, Project.MSG_ERR);
				}
				if (failOnError) {
					throw new BuildException(getTaskName() + " failed; please see output for details.");
				}
			}

			if (this.outputProperty != null) {
				// FIXME
				// getProject().setProperty(outputProperty, output.toString());
			}
		}
	}

	protected void process() throws BuildException {
		process(getFiles());
	}

	protected void process(List<File> files) throws BuildException {
		for (File file : files) {
			Executor executor = new Executor(this);
			executor.init(file);
			scheduler.addTask(executor);
		}
		if (threadCount < 1) {
			threadCount = MAX_ALLOWED_THREADS;
		}
		scheduler.setThreadCount(threadCount);
		scheduler.execute();
	}

	protected void validateParameters() throws BuildException {

	}

	protected List<File> getFiles() {
		ArrayList<File> files = new ArrayList<File>();

		// FIXME : clarify when do we need this
		if (!parallel && srcDir != null) {
			files.add(srcDir);
			return files;
		}
		DirectoryScanner ds;
		File basedir;
		for (ResourceCollection fs : sources) {
			ds = ((FileSet) fs).getDirectoryScanner(getProject());
			basedir = ((FileSet) fs).getDir(getProject());
			String[] paths = ds.getIncludedFiles();
			for (String path : paths) {
				File file = new File(basedir, path);
				files.add(file);
			}
		}
		return files;
	}

	protected String getLogo() {
		return logo;
	}

	protected Vector<String> getFailures() {
		return failures;
	}

	private void displayLogo() {
		ExecTask executor = new ExecTask(this);
		File executable = resolveExecutable();
		String outputPropertyName = "php.logo";
		if (tool != null) {
			outputPropertyName = "php." + tool + ".logo";
		}

		executor.init();

		executor.setExecutable(executable.toString());
		executor.setResolveExecutable(false);

		executor.createArg().setValue("-n");
		executor.createArg().setValue("-d");
		executor.createArg().setValue("date.timezone=America/New_York");

		executor.createArg().setValue("-d");
		executor.createArg().setValue("extension_dir=" + resolveExtensionsDirectory());

		for (Map.Entry<String, String> extension : extensions.entrySet()) {
			File extLib = new File(extDir, extension.getKey());
			// special handling for zend_extensions
			if (extension.getValue().contains("zend")) {
				extLib = new File(extension.getKey());
			}
			if (extLib.exists()) {
				executor.createArg().setValue("-d");
				executor.createArg().setValue(extension.getValue() + extension.getKey());
			}
		}

		if (tool != null) {
			executor.createArg().setFile(resolveTool(tool));
		}
		executor.createArg().setValue("--version");

		executor.setOutputproperty(outputPropertyName);

		try {
			if (executor != null) {
				executor.execute();
				logo = getProject().getProperty(outputPropertyName);
				log("--------------------------------------------------------------------------------");
				log(logo);
				log("--------------------------------------------------------------------------------");
			}
		} catch (Exception e) {
			// DO NOTHING
		}

	}

	/**
	 * Allows tasks to define php configuration (ini) entries.
	 * 
	 * This method should be called during task's initialization
	 * <code>Task::init()</code>
	 * 
	 * @param name
	 * @param value
	 */
	protected void define(String name, String value) {
		createIni().createEntry().setName(name).setValue(value);
	}

	/**
	 * Allows tasks to specify which extensions need to be loaded so that they can
	 * execute successfully.
	 * 
	 * This method should be called during task's initialization.
	 * 
	 * @param name
	 */
	protected void useExtension(String name) {
		useExtension(name, false);
	}

	/**
	 * Allows tasks to specify which zend extension need to be loaded.
	 * 
	 * This method should be called during task's initialization.
	 * 
	 * @param name
	 * @param isZendExtension
	 */
	protected void useExtension(String name, boolean isZendExtension) {

		name = name.toLowerCase();
		if (Os.isFamily(Os.FAMILY_WINDOWS)) {
			name = "php_" + name + ".dll";
		} else {
			name = name + ".so";
		}

		if (isZendExtension) {
			name = new File(this.resolveExtensionsDirectory(), name).getAbsolutePath();
		}
		if (extensions.containsKey(name)) {
			return;
		}
		if (isZendExtension) {
			extensions.put(name, "zend_extension=");
		} else {
			extensions.put(name, "extension=");
		}

	}

	private File resolveExecutable() {
		if (resolvedExec != null) {
			return resolvedExec;
		}
		resolvedExec = getProject().resolveFile(exec);

		if (resolvedExec.exists()) {
			return resolvedExec;
		}

		// attempt to locate php in the working directory if one is given
		if (workDir != null) {
			resolvedExec = FileUtils.getFileUtils().resolveFile(workDir, exec);
			if (resolvedExec.exists()) {
				return resolvedExec;
			}
		}

		// attempt to locate php in the directory specified by the php.dir
		// property
		String phpDir = getProject().getProperty(PROPERTY_PHP_DIR);
		if (phpDir != null) {
			resolvedExec = FileUtils.getFileUtils().resolveFile(new File(phpDir), exec);
			if (resolvedExec.exists()) {
				log(String.format("Found %s in ${%s} directory", exec, PROPERTY_PHP_DIR), Project.MSG_DEBUG);
				return resolvedExec;
			} else {
				log(String.format("Failed to locate %s in ${%s} directory", exec, PROPERTY_PHP_DIR), Project.MSG_DEBUG);
			}
		}

		// attempt to locate php by using the environment variables

		String[] local = env.getVariables();
		Map<String, String> system = Execute.getEnvironmentVariables();

		// try using the PHP_HOME in the task environment

		if (local != null) {
			for (int i = 0; i < local.length; i++) {
				if (local[i].startsWith("PHP_HOME")) {
					log("Found PHP_HOME in task environment variables", Project.MSG_DEBUG);
					resolvedExec = FileUtils.getFileUtils().resolveFile(new File(local[i].substring("PATH=".length())),
							exec);
					if (resolvedExec.exists()) {
						log(String.format("Found %s binary in %s", exec, local[i].substring("PATH=".length())),
								Project.MSG_DEBUG);
						return resolvedExec;
					}
				}
			}
		}

		// try using the PHP_HOME in the system environment
		if (system.get("PHP_HOME") != null) {
			log("Found PHP_HOME in system environment variables : " + system.get("PHP_HOME"), Project.MSG_DEBUG);
			resolvedExec = FileUtils.getFileUtils().resolveFile(new File(system.get("PHP_HOME")), exec);
			if (resolvedExec.exists()) {
				log(String.format("Found %s binary in %s", exec, system.get("PHP_HOME")), Project.MSG_DEBUG);
				return resolvedExec;
			}

		}
		// all attempts have fail so attempt to find php in the Path variable
		// (both in the local task system environments)

		Path p = null;
		if (local != null) {
			for (int i = 0; i < local.length; i++) {
				if (local[i].startsWith("PATH=") || local[i].startsWith("Path=")) {
					p = new Path(getProject(), local[i].substring("PATH=".length()));
					break;
				}
			}
		}
		if (p == null) {
			String path = Execute.getEnvironmentVariables().get("PATH");
			if (path == null) {
				path = Execute.getEnvironmentVariables().get("Path");
			}

			if (path != null) {
				p = new Path(getProject(), path);
			}
		}
		if (p != null) {
			String[] dirs = p.list();
			for (int i = 0; i < dirs.length; i++) {
				resolvedExec = FileUtils.getFileUtils().resolveFile(new File(dirs[i]), exec);
				if (resolvedExec.exists()) {
					return resolvedExec;
				}
			}
		}

		return resolvedExec;
	}

	private File resolveExtensionsDirectory() throws BuildException {
		if (extDir != null) {
			return extDir;
		}

		File phpExec = resolveExecutable();
		File phpBinDir = phpExec.getParentFile();
		File phpExtDir = new File(phpBinDir, "ext");
		extDir = FileUtils.getFileUtils().normalize(phpExtDir.toString());
		if (!extDir.exists()) {
			throw new BuildException("Failed to find the php extension_dir : " + extDir);
		}
		return extDir;
	}

	private synchronized File resolveTool(String tool) {
		if (tool.equals("phpunit-6.4.2")) {

			return new File("O:\\work\\opfx\\proj\\ant\\master\\paratest\\vendor\\phpunit\\phpunit\\phpunit");
		}
		log(String.format("Resolving tool '%s'...", tool), Project.MSG_DEBUG);
		File result = new File(System.getProperty("java.io.tmpdir") + File.separatorChar + "ant-php", tool + ".phar");
		if (!result.exists()) {
			try {
				extractResource(String.format(FMT_RESOURCE_PATH_TOOL, tool), result.getAbsolutePath());
			} catch (IOException e) {
				throw new BuildException(String.format("Failed to extract tool '%s'.", tool), e, getLocation());
			}
		}
		return result;
	}

	protected synchronized File resolveScript(String script) throws BuildException {
		log(String.format("Resolving script '%s'", script), Project.MSG_VERBOSE);
		File result = new File(System.getProperty("java.io.tmpdir") + File.separatorChar + "ant-php", script + ".php");
		if (!result.exists()) {
			try {
				extractResource(String.format(FMT_RESOURCE_PATH_SCRIPT, script), result.getAbsolutePath());
			} catch (IOException e) {
				throw new BuildException(String.format("Failed to extract script '%s'.", script), e, getLocation());
			}
		}
		return result;
	}

	/**
	 * Resolves the requested template.
	 * 
	 * @param template
	 * @return
	 * @throws BuildException
	 */
	protected File resolveTemplate(String template) throws BuildException {
		log(String.format("Resolving template '%s'", template), Project.MSG_VERBOSE);
		File result = new File(System.getProperty("java.io.tmpdir") + File.separatorChar + "ant-php", template);
		if (!result.exists()) {
			try {
				extractResource(String.format(FMT_RESOURCE_PATH_TEMPLATE, template), result.getAbsolutePath());
			} catch (IOException e) {
				throw new BuildException(String.format("Failed to extract template '%s'.", template), e, getLocation());
			}
		}
		return result;
	}

	/**
	 * 
	 * @param source
	 * @param target
	 * @throws IOException
	 */
	private void extractResource(String source, String target) throws IOException {
		log(String.format("Extracting resource '%s' to '%s'", source, target), Project.MSG_VERBOSE);
		InputStream input = null;
		OutputStream output = null;

		try {
			input = getClass().getClassLoader().getResourceAsStream(source);
			if (input == null) {
				throw new FileNotFoundException("Failed to locate resource " + source);
			}
			new File(target).getParentFile().mkdirs();
			output = new FileOutputStream(target);
			byte[] buffer = new byte[4096];
			int readBytes = 0;
			while ((readBytes = input.read(buffer)) > 0) {
				output.write(buffer, 0, readBytes);
			}
		} finally {
			if (input != null) {
				try {
					input.close();
				} catch (IOException e) {
					// do nothing
				}
			}
			if (output != null) {
				try {
					output.close();
				} catch (IOException e) {
					// do nothing
				}
			}
		}
	}

	private synchronized void configure(Executor executor) {

		File phpBin = this.resolveExecutable();
		executor.setExecutable(phpBin.toString());
		executor.setResolveExecutable(false);
		executor.setDir(workDir);

		Commandline opts = executor.opts;
		opts.createArgument().setValue("-n");

		opts.createArgument().setValue("-d");
		opts.createArgument().setValue("extension_dir=" + resolveExtensionsDirectory());

		for (Map.Entry<String, String> extension : extensions.entrySet()) {
			File extLib = new File(extDir, extension.getKey());
			// special handling for zend_extensions
			if (extension.getValue().contains("zend")) {
				extLib = new File(extension.getKey());
			}
			if (extLib.exists()) {
				opts.createArgument().setValue("-d");
				opts.createArgument().setValue(extension.getValue() + extension.getKey());
			}
		}

		for (IniSet iniset : defines) {
			for (IniSet.Entry define : iniset) {
				opts.createArgument().setValue("-d");
				opts.createArgument().setValue(define.getName() + "=" + define.getValue());
			}
		}

		configureOptions(opts);
		executor.getCommandline().addArguments(opts.getArguments());

		if (tool != null) {
			executor.getCommandline().createArgument().setFile(resolveTool(this.tool));
			configureArguments(executor.args);
			executor.getCommandline().addArguments(executor.args.getArguments());

		}

		executor.getCommandline().createArgument().setFile(executor.file);

		if (tool == null) {
			configureArguments(executor.args);
			executor.getCommandline().addArguments(executor.args.getArguments());
		}

		// configure the executor's environment
		configureEnvironment(executor.env, executor);
		Vector<Variable> vars = executor.env.getVariablesVector();
		for (Variable var : vars) {
			executor.addEnv(var);
		}

	}

	private synchronized void finalize(Executor executor) {
		complete(executor);
		log(executor.getOutput().replace(logo, ""), Project.MSG_INFO);
		if (executor.getResult() != 0 || !executor.getError().isEmpty()) {
			String error = executor.getError();
			if (error.isEmpty()) {
				error = executor.getOutput().replace(logo, "");
			}
			failures.add(error);
		}
	}

	/**
	 * Allows subclasses to configure the executor's options.
	 * 
	 * This implementation does nothing and is provided as a convenience so that
	 * subclasses that do not have contributions to the executor's options are not
	 * forced to implement it.
	 * 
	 * Subclasses that choose to implement this method do not have to call this
	 * implementation.
	 * 
	 * @param opts
	 * @param executor
	 */
	protected void configureOptions(Commandline opts) {

	}

	/**
	 * Allows subclasses to configure the executor's arguments.
	 * 
	 * This implementation does nothing and is provided as a convenience so that
	 * subclasses that do not have contributions to the executor's arguments do not
	 * have to implement it.
	 * 
	 * Subclasses that choose to implement this method do not have to call this
	 * implementation,
	 * 
	 * @param args
	 * @param executor
	 */
	protected void configureArguments(Commandline args) {

	}

	/**
	 * Allows subclasses to configure the executor's environment.
	 * 
	 * This implementions does nothing and is provided as a convenience so that
	 * subclasses that do not have contributions to the executor's environment do
	 * not have to implement this method.
	 * 
	 * Subclasses that choose to implement this method do not have to call this
	 * implementation.
	 * 
	 * @param env
	 */
	protected void configureEnvironment(Environment env, Executor executor) {

	}

	protected void complete(Executor executor) {

	}

	public static class Executor extends ExecTask {
		private AbstractTask owner;
		private File file;

		private UUID uuid;
		private Commandline opts;
		private Commandline args;
		private Environment env;

		private int result;
		private String output;
		private String error;

		public Executor(AbstractTask task) {
			super(task);
			uuid = UUID.randomUUID();
			owner = task;

			opts = new Commandline();
			args = new Commandline();
			env = new Environment();
		}

		public UUID getGuid() {
			return uuid;
		}

		public Commandline getCommandline() {
			return cmdl;
		}

		public File getFile() {
			return file;
		}

		protected Redirector getRedirector() {
			return redirector;
		}

		public String getOutput() {
			return output;
		}

		public void setOutput(String value) {
			output = value;
		}

		public int getResult() {
			return result;
		}

		public String getError() {
			return error;
		}

		public void setError(String value) {
			error = value;
		}

		public void init(File file) {
			super.init();
			this.file = file;
		}

		@Override
		public void execute() throws BuildException {

			redirector.setOutputFilterChains(owner.outputFilterChains);
			owner.configure(this);

			setOutputproperty(uuid + ".output");
			setResultProperty(uuid + ".result");
			setErrorProperty(uuid + ".error");

			super.execute();
			result = Integer.valueOf(getProject().getProperty(uuid + ".result"));
			output = getProject().getProperty(uuid + ".output");
			output = output.replaceAll("(?m)^[ \t]*\r?\n", "");
			error = getProject().getProperty(uuid + ".error");

			owner.finalize(this);
		}

		@Override
		public void log(String message, int level) {
			// filter out the "Result: -n" message logged by the
			// executor in case php exits with an error code
			if (message.contains("Result:")) {
				return;
			}

			// FIXME
			if (level == Project.MSG_VERBOSE && message.contains("Executing")) {
				// if (message.contains("Executing")) {
				message = message.replaceAll("\r", "");
				message = message.replaceAll("\n", " ");
				message = message.replace(
						"The ' characters around the executable and arguments are not part of the command.", "");
				message = message.replace("Executing", "Executing:");
				message = message.replace("with arguments: ", "");
				message = message.replace("'", "");
				// FIXME
				// level = owner.verbosity;
				// level = Project.MSG_INFO;
			}
			super.log(message, level);
		}

	}

}
